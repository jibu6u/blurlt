<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Oculus/WebXR • Per-Eye Blur + 3 Modes • v8</title>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif}
  #hud{position:fixed;left:16px;top:16px;z-index:20;background:rgba(0,0,0,.85);color:#fff;
       border:1px solid rgba(255,255,255,.15);border-radius:12px;padding:12px;min-width:360px;backdrop-filter:blur(4px)}
  #hud h3{margin:0 0 8px;color:#82d0ff;font-size:15px}
  .row{display:flex;align-items:center;gap:8px;margin:6px 0;flex-wrap:wrap}
  label{font-size:12px;white-space:nowrap}
  input[type=range]{width:170px}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.1);font-size:12px}
  button{appearance:none;border:0;border-radius:8px;padding:6px 10px;color:#fff;background:#3a86ff;cursor:pointer}
  button.ghost{background:#555}
  #dbg{position:fixed;left:16px;top:180px;color:#b3e5c1;z-index:19;font:12px/1.5 ui-monospace,Menlo,Consolas,monospace;
       background:rgba(0,0,0,.45);padding:8px 10px;border-radius:8px;min-width:360px}
  #seedCanvas{position:fixed;inset:0;display:block;z-index:10;pointer-events:auto;touch-action:none;cursor:crosshair}
  #stage{position:fixed;inset:0;z-index:0}
  #help{position:fixed;right:16px;bottom:16px;color:#ccc;background:rgba(0,0,0,.45);padding:6px 8px;border-radius:8px;font-size:12px;z-index:5}
  .mode{display:flex;gap:10px}
  .mode label{display:flex;align-items:center;gap:6px}
</style>
</head>
<body>
  <div id="hud">
    <h3>Oculus/WebXR · 좌/우 개별 블러 + 3모드 (v8)</h3>
    <div class="row">시드: <span id="seedVal" class="pill">없음</span> · 점 <span id="ptCount" class="pill">0/7</span></div>

    <div class="row"><label>팔레트 크기: <span id="palSzVal" class="pill">240</span></label>
      <input id="palSz" type="range" min="16" max="288" step="1" value="240">
      <span id="palCount" class="pill">0색</span>
    </div>

    <div class="row">
      <button id="startBtn">시작</button>
      <button id="stopBtn" class="ghost">중지</button>
      <button id="resetBtn" class="ghost">리셋</button>
      <button id="enterVR">Enter VR</button>
    </div>

    <div class="row"><label>수명(초): <span id="speedVal" class="pill">3.0</span></label>
      <input id="speed" type="range" min="1" max="10" step="0.5" value="3"></div>
    <div class="row"><label>스폰주기(ms): <span id="freqVal" class="pill">900</span></label>
      <input id="freq" type="range" min="100" max="3000" step="50" value="900"></div>
    <div class="row"><label>동시 스폰: <span id="densVal" class="pill">2</span></label>
      <input id="dens" type="range" min="1" max="6" step="1" value="2"></div>

    <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);width:100%">

    <div class="row"><label>블러(공통) : <span id="blurVal" class="pill">0%</span></label>
      <input id="blur" type="range" min="0" max="20" step="1" value="0">
    </div>
    <div class="row"><label>좌안 추가 : <span id="leftBiasVal" class="pill">0%</span></label>
      <input id="leftBias" type="range" min="0" max="20" step="1" value="0">
    </div>
    <div class="row"><label>우안 추가 : <span id="rightBiasVal" class="pill">0%</span></label>
      <input id="rightBias" type="range" min="0" max="20" step="1" value="0">
    </div>

    <div class="row mode">
      <label><input type="radio" name="mode" value="bias" checked> 가중치 모드</label>
      <label><input type="radio" name="mode" value="viewL"> 좌안만 보기</label>
      <label><input type="radio" name="mode" value="viewR"> 우안만 보기</label>
    </div>
  </div>

  <div id="dbg">[READY] 7점을 찍어 시드를 만드세요. (클릭/터치/마우스다운 모두 지원)</div>
  <canvas id="seedCanvas"></canvas>
  <div id="stage"></div>
  <div id="help">7점 → 시작 → Enter VR(HTTPS). 좌/우 별도 뷰포트 + 개별 블러.</div>

  <!-- A. 시드/팔레트/입력 -->
  <script>
  (function(){
    const $=id=>document.getElementById(id);
    const can=$('seedCanvas'), ctx=can.getContext('2d'), dbg=$('dbg');
    const MAXPTS=7;
    const state={points:[], seed:null, palette:[], running:false};
    function fit(){ can.width=innerWidth; can.height=innerHeight; draw(); }
    function say(s){ dbg.textContent=s; console.log(s); }
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    function hslToHex(h,s,l){
      l=clamp(l,0,1); s=clamp(s,0,1);
      const c=(1-Math.abs(2*l-1))*s, hp=((h%360)+360)%360/60, x=c*(1-Math.abs(hp%2-1));
      let r=0,g=0,b=0;
      if(hp<1){r=c;g=x;} else if(hp<2){r=x;g=c;} else if(hp<3){g=c;b=x;} else if(hp<4){g=x;b=c;} else if(hp<5){r=x;b=c;} else {r=c;b=x;}
      const m=l-c/2; r=Math.round((r+m)*255); g=Math.round((g+m)*255); b=Math.round((b+m)*255);
      return "#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
    }
    function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;};}
    function computeSeed(){ let s=0; state.points.forEach((p,i)=>{ s^=(((p.x|0)+(p.y|0))<<(i%24)); }); return (s>>>0)||0xA5A5A5A5; }

    function buildSeedAndPalette(){
      state.seed = computeSeed(); $('seedVal').textContent = state.seed;
      const rng = mulberry32(state.seed); const base = Math.floor(rng()*360);
      const N = Number($('palSz').value); const arr=[];
      for(let i=0;i<N;i++){
        const h=(base+i*(360/N) + (rng()*2-1)*8 + 360)%360;
        const s=Math.max(0.35, Math.min(0.55, 0.35 + rng()*0.20)); // 채도 낮춤
        const l=Math.max(0.70, Math.min(0.85, 0.70 + rng()*0.15)); // 밝게
        arr.push(hslToHex(h,s,l));
      }
      state.palette = arr; $('palCount').textContent = arr.length+"색";
      say(`[SEED] 밝은 팔레트 ${N}색 생성 (S 0.35~0.55, L 0.70~0.85)`);
    }

    function draw(){
      ctx.clearRect(0,0,can.width,can.height);
      ctx.fillStyle="#ffee66"; state.points.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); });
      if(state.points.length===MAXPTS){
        ctx.strokeStyle="#ffeb3b"; ctx.lineWidth=2; let idx=0;
        ctx.beginPath(); ctx.moveTo(state.points[idx].x,state.points[idx].y);
        for(let k=0;k<MAXPTS;k++){ idx=(idx+2)%MAXPTS; ctx.lineTo(state.points[idx].x,state.points[idx].y); }
        ctx.closePath(); ctx.stroke();
      }
    }
    function rel(e){ const r=can.getBoundingClientRect(); const p=(e.touches?e.touches[0]:e); return {x:p.clientX-r.left,y:p.clientY-r.top}; }
    let lock=0,last={x:-1e9,y:-1e9};
    function addPoint(p){
      const dx=p.x-last.x, dy=p.y-last.y; if(dx*dx+dy*dy<25) return;
      if(state.points.length>=MAXPTS) return;
      state.points.push(p); last=p;
      $('ptCount').textContent=state.points.length+'/'+MAXPTS; draw();
      if(state.points.length===MAXPTS){ buildSeedAndPalette(); }
    }
    function onAnyDown(e){
      if(can.style.display==='none') return;
      const now=performance.now(); if(now<lock) return; lock=now+80;
      addPoint(rel(e)); e.preventDefault?.();
    }
    can.addEventListener('pointerdown', onAnyDown);
    can.addEventListener('mousedown', onAnyDown);
    can.addEventListener('click', onAnyDown);
    can.addEventListener('touchstart', onAnyDown, {passive:false});
    window.addEventListener('resize', fit); fit();

    const speedEl=$('speed'), freqEl=$('freq'), densEl=$('dens');
    const speedVal=$('speedVal'), freqVal=$('freqVal'), densVal=$('densVal');
    const palSz=$('palSz'), palSzVal=$('palSzVal');
    const blurEl=$('blur'), blurVal=$('blurVal');
    const leftBias=$('leftBias'), leftBiasVal=$('leftBiasVal');
    const rightBias=$('rightBias'), rightBiasVal=$('rightBiasVal');

    const modeRadios = Array.from(document.querySelectorAll('input[name="mode"]'));
    const modeVal = ()=> (modeRadios.find(r=>r.checked)?.value||'bias');

    function syncUI(){
      speedVal.textContent=speedEl.value; freqVal.textContent=freqEl.value; densVal.textContent=densEl.value;
      palSzVal.textContent=palSz.value; blurVal.textContent=blurEl.value+"%";
      leftBiasVal.textContent=leftBias.value+"%"; rightBiasVal.textContent=rightBias.value+"%";
    }
    ['input','change'].forEach(ev=>{
      [speedEl,freqEl,densEl,palSz,blurEl,leftBias,rightBias].forEach(el=>el.addEventListener(ev,()=>{
        syncUI(); if(el===palSz && state.points.length===MAXPTS){ buildSeedAndPalette(); }
      }));
      modeRadios.forEach(r=>r.addEventListener(ev, syncUI));
    });
    syncUI();

    $('startBtn').onclick=()=>{
      if(state.seed==null){ alert("먼저 7점을 찍으세요."); return; }
      if(!state.running){ state.running=true; say("[RUN] 시작"); can.style.display="none"; window.dispatchEvent(new CustomEvent('app:start')); }
    };
    $('stopBtn').onclick=()=>{ state.running=false; say("[STOP] 중지"); };
    $('resetBtn').onclick=()=>{ state.running=false; state.seed=null; state.palette=[]; state.points=[];
      $('ptCount').textContent="0/7"; $('seedVal').textContent="없음"; $('palCount').textContent="0색";
      can.style.display="block"; draw(); say("[RESET] 초기화"); };

    window.AppXR = { state, say,
      ui:{ speedEl,freqEl,densEl, blurEl,leftBias,rightBias, modeVal } };
  })();
  </script>

  <!-- B. XR 렌더/후처리 -->
  <script type="module">
  import * as THREE from 'three';
  import { VRButton } from 'three/addons/webxr/VRButton.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
  import { HorizontalBlurShader } from 'three/addons/shaders/HorizontalBlurShader.js';
  import { VerticalBlurShader } from 'three/addons/shaders/VerticalBlurShader.js';

  const { state, say, ui } = window.AppXR;
  const { speedEl, freqEl, densEl, blurEl, leftBias, rightBias, modeVal } = ui;

  const stage=document.getElementById('stage');
  const renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio||1, 1.8));
  renderer.setSize(innerWidth,innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.15;
  renderer.xr.enabled=true;
  renderer.xr.setReferenceSpaceType('local-floor');
  stage.appendChild(renderer.domElement);

  const scene=new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const baseCam=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,0.1,2000);
  baseCam.position.set(0,1.4,4); scene.add(baseCam);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 1.0); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.05); dir.position.set(2,4,3); scene.add(dir);
  const grid = new THREE.GridHelper(20, 20, 0x444444, 0x222222); grid.position.y = -1.5; scene.add(grid);

  const group=new THREE.Group(); scene.add(group);
  let cubes=[];

  function colorFromPalette(rng){ return new THREE.Color(state.palette[Math.floor(rng()*state.palette.length)]||"#ffffff"); }
  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;};}

  // === "멀리서 -> 나에게" 직선 접근 ===
  function createBox(rng){
    const sx = 0.25 + rng()*0.75;
    const sy = 0.25 + rng()*0.75;
    const sz = 0.25 + rng()*1.20;
    const g = new THREE.BoxGeometry(sx, sy, sz);
    const m = new THREE.MeshStandardMaterial({ color: colorFromPalette(rng), metalness:0.05, roughness:0.6, transparent:true, opacity:1 });
    const mesh = new THREE.Mesh(g, m);

    // Z 멀리서 시작, X/Y는 약간 랜덤
    const zStart = -12 - rng()*6;     // -12 ~ -18
    const xStart = (rng()-0.5)*2.8;   // 좌우 약간 퍼짐
    const yStart = (rng()-0.5)*1.8;
    mesh.position.set(xStart, yStart, zStart);
    mesh.rotation.set(rng()*Math.PI, rng()*Math.PI, rng()*Math.PI);

    // 수명 동안 zEnd로 접근하도록 속도 설정
    const lifeMs = Number(speedEl.value)*1000;
    const lifeS  = Math.max(lifeMs/1000, 0.5);
    const zEnd   =  2.6;                         // 카메라 앞까지
    const velZ   = (zEnd - zStart) / lifeS;      // 초당 z 증가량
    const velX   = (rng()*0.16 - 0.08);          // 가벼운 좌우 드리프트
    const swayA  = 0.08 + rng()*0.12;            // Y 미세 흔들림
    const swayHz = 0.5 + rng()*0.6;

    mesh.userData = {
      zStart, zEnd, velZ, velX,
      yBase: yStart, swayA, swayHz, phase: rng()*Math.PI*2,
      dieAt: performance.now() + lifeMs, lifeTotal: lifeMs
    };

    group.add(mesh); cubes.push(mesh);
  }

  function spawn(now){
    if(!state.seed || !state.palette.length || !state.running) return;
    const base=(state.seed^(now|0))>>>0;
    const rng = mulberry32(base);
    for(let i=0;i<Number(densEl.value);i++) createBox(rng);
  }
  window.addEventListener('app:start', ()=>{ spawn(performance.now()); });

  // per-eye composers
  const compL = new EffectComposer(renderer);
  const passL = new RenderPass(scene, baseCam);
  const hL = new ShaderPass(HorizontalBlurShader), vL = new ShaderPass(VerticalBlurShader); vL.renderToScreen = true;
  compL.addPass(passL); compL.addPass(hL); compL.addPass(vL);

  const compR = new EffectComposer(renderer);
  const passR = new RenderPass(scene, baseCam);
  const hR = new ShaderPass(HorizontalBlurShader), vR = new ShaderPass(VerticalBlurShader); vR.renderToScreen = true;
  compR.addPass(passR); compR.addPass(hR); compR.addPass(vR);

  function setBlur(pct, w, h, isLeft){
    const amt = pct * 0.1;
    (isLeft?hL:hR).uniforms.h.value = (amt)/(w||1);
    (isLeft?vL:vR).uniforms.v.value = (amt)/(h||1);
  }

  function renderXRPerEye(){
    const xrCam = renderer.xr.getCamera(baseCam);
    const gl = renderer.getContext();
    const totalW = gl.drawingBufferWidth, totalH = gl.drawingBufferHeight;
    compL.setSize(totalW,totalH); compR.setSize(totalW,totalH);
    renderer.setScissorTest(true);

    const mode = modeVal();
    const basePct = Number(blurEl.value);
    const lPct = basePct + Number(leftBias.value);
    const rPct = basePct + Number(rightBias.value);

    for(let i=0;i<2;i++){
      const sub = xrCam.cameras[i];
      const vp = sub.viewport;
      let camToUse = sub;
      if(mode==='viewL') camToUse = xrCam.cameras[0];
      else if(mode==='viewR') camToUse = xrCam.cameras[1];

      renderer.setViewport(vp.x, vp.y, vp.z, vp.w);
      renderer.setScissor(vp.x, vp.y, vp.z, vp.w);

      const pct = (mode==='bias') ? (i===0?lPct:rPct) : (mode==='viewL'?lPct:rPct);
      passL.camera = camToUse; passR.camera = camToUse;
      setBlur(pct, vp.z, vp.w, i===0);

      if(i===0) compL.render(); else { renderer.clearDepth(); compR.render(); }
    }
    renderer.setScissorTest(false);
  }

  function renderMono(){
    const w = renderer.domElement.width, h = renderer.domElement.height;
    compL.setSize(w,h); setBlur(Number(blurEl.value), w,h, true);
    passL.camera = baseCam; compL.render();
  }

  let prevTime = performance.now(), lastSpawn = 0;
  function loop(now){
    const dt = Math.min((now - prevTime)/1000, 0.05); prevTime = now;

    if(state.running){
      const freq = Number(freqEl.value);
      if(now - lastSpawn >= freq){ spawn(now); lastSpawn = now; }
    }

    const t = performance.now();
    for(let i=cubes.length-1;i>=0;i--){
      const m = cubes[i], u = m.userData;

      // 회전: 자연스럽게
      m.rotation.x += 0.6 * dt;
      m.rotation.y += 0.5 * dt;

      // 정면 접근 (Z+) + 약한 좌우 드리프트 + Y 미세 흔들림
      u.phase += dt * 2*Math.PI * u.swayHz;
      m.position.z += u.velZ * dt;
      m.position.x += u.velX * dt;
      m.position.y = u.yBase + Math.sin(u.phase) * u.swayA;

      // 페이드아웃(수명 기반 & zEnd 도달)
      const lifeLeft = (u.dieAt - t) / u.lifeTotal;
      let alpha = THREE.MathUtils.clamp(lifeLeft, 0, 1);
      if(m.position.z >= u.zEnd){
        const k = THREE.MathUtils.clamp((m.position.z - u.zEnd)/0.8, 0, 1);
        alpha *= (1 - k);
      }
      m.material.opacity = alpha;

      if(alpha<=0.01 || t>=u.dieAt || m.position.z>u.zEnd+1.0){
        group.remove(m); m.geometry.dispose(); m.material.dispose(); cubes.splice(i,1);
      }
    }

    if(renderer.xr.isPresenting) renderXRPerEye(); else renderMono();

    document.getElementById('dbg').textContent =
      `[${renderer.xr.isPresenting?'XR':'MONO'}] cubes=${cubes.length} mode=${modeVal()} blur=${blurEl.value}% L+=${leftBias.value}% R+=${rightBias.value}%`;
  }
  renderer.setAnimationLoop(loop);

  window.addEventListener('resize', ()=>{
    renderer.setSize(innerWidth,innerHeight,false);
    baseCam.aspect = innerWidth/innerHeight; baseCam.updateProjectionMatrix();
    compL.setSize(innerWidth,innerHeight); compR.setSize(innerWidth,innerHeight);
  });

  const vrBtn = VRButton.createButton(renderer);
  vrBtn.style.position='fixed'; vrBtn.style.right='16px'; vrBtn.style.top='16px'; vrBtn.style.zIndex='30';
  document.body.appendChild(vrBtn);
  document.getElementById('enterVR').onclick = ()=> vrBtn.click();
  </script>
</body>
</html>
