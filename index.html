<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Oculus/WebXR • Per-Eye Blur + 3 Modes • v5</title>

  <!-- Import Map: three / addons 경로 지정 (모듈 로딩 실패 방지) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif}
    #hud{position:fixed;left:16px;top:16px;z-index:20;background:rgba(0,0,0,.85);color:#fff;
         border:1px solid rgba(255,255,255,.15);border-radius:12px;padding:12px;min-width:360px;backdrop-filter:blur(4px)}
    #hud h3{margin:0 0 8px;color:#82d0ff;font-size:15px}
    .row{display:flex;align-items:center;gap:8px;margin:6px 0;flex-wrap:wrap}
    label{font-size:12px;white-space:nowrap}
    input[type=range]{width:170px}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.1);font-size:12px}
    button{appearance:none;border:0;border-radius:8px;padding:6px 10px;color:#fff;background:#3a86ff;cursor:pointer}
    button.ghost{background:#555}
    #dbg{position:fixed;left:16px;top:180px;color:#b3e5c1;z-index:19;font:12px/1.5 ui-monospace,Menlo,Consolas,monospace;
         background:rgba(0,0,0,.45);padding:8px 10px;border-radius:8px;min-width:360px}
    #seedCanvas{position:fixed;inset:0;display:block;z-index:10;pointer-events:auto;touch-action:none;cursor:crosshair}
    #stage{position:fixed;inset:0;z-index:0}
    #help{position:fixed;right:16px;bottom:16px;color:#ccc;background:rgba(0,0,0,.45);padding:6px 8px;border-radius:8px;font-size:12px;z-index:5}
    .mode{display:flex;gap:10px}
    .mode label{display:flex;align-items:center;gap:6px}
  </style>
</head>
<body>
  <div id="hud">
    <h3>Oculus/WebXR · 좌/우 개별 블러 + 3모드 (v5)</h3>
    <div class="row">시드: <span id="seedVal" class="pill">없음</span> · 점 <span id="ptCount" class="pill">0/7</span></div>

    <div class="row"><label>팔레트 크기: <span id="palSzVal" class="pill">240</span></label>
      <input id="palSz" type="range" min="16" max="288" step="1" value="240">
      <span id="palCount" class="pill">0색</span>
    </div>

    <div class="row">
      <button id="startBtn">시작</button>
      <button id="stopBtn" class="ghost">중지</button>
      <button id="resetBtn" class="ghost">리셋</button>
      <button id="enterVR">Enter VR</button>
    </div>

    <div class="row"><label>수명(초): <span id="speedVal" class="pill">3.0</span></label>
      <input id="speed" type="range" min="1" max="8" step="0.5" value="3"></div>
    <div class="row"><label>스폰주기(ms): <span id="freqVal" class="pill">800</span></label>
      <input id="freq" type="range" min="100" max="2000" step="50" value="800"></div>
    <div class="row"><label>동시 스폰: <span id="densVal" class="pill">3</span></label>
      <input id="dens" type="range" min="1" max="8" step="1" value="3"></div>

    <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);width:100%">

    <div class="row"><label>블러(공통) : <span id="blurVal" class="pill">8%</span></label>
      <input id="blur" type="range" min="0" max="20" step="1" value="8">
    </div>
    <div class="row"><label>좌안 추가 : <span id="leftBiasVal" class="pill">5%</span></label>
      <input id="leftBias" type="range" min="0" max="20" step="1" value="5">
    </div>
    <div class="row"><label>우안 추가 : <span id="rightBiasVal" class="pill">0%</span></label>
      <input id="rightBias" type="range" min="0" max="20" step="1" value="0">
    </div>

    <div class="row mode">
      <label><input type="radio" name="mode" value="bias" checked> 가중치 모드</label>
      <label><input type="radio" name="mode" value="viewL"> 좌안만 보기</label>
      <label><input type="radio" name="mode" value="viewR"> 우안만 보기</label>
    </div>
  </div>

  <div id="dbg">[READY] VR 들어가기 전 7점을 찍어 시드를 만드세요.</div>
  <canvas id="seedCanvas"></canvas>
  <div id="stage"></div>
  <div id="help">7점 → 시작 → Enter VR(HTTPS 권장). 좌/우 별도 뷰포트 렌더 + 개별 블러.</div>

  <!-- (A) 시드/팔레트/버튼: 모듈 없이 선실행 -->
  <script>
    (function(){
      const $=id=>document.getElementById(id);
      const can=$('seedCanvas'), ctx=can.getContext('2d'), dbg=$('dbg');
      const MAXPTS=7;
      const state={points:[], seed:null, palette:[], running:false};
      function fit(){ can.width=innerWidth; can.height=innerHeight; draw(); }
      function say(s){ dbg.textContent=s; console.log(s); }
      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
      function hslToHex(h,s,l){
        l=clamp(l,0,1); s=clamp(s,0,1);
        const c=(1-Math.abs(2*l-1))*s, hp=((h%360)+360)%360/60, x=c*(1-Math.abs(hp%2-1));
        let r=0,g=0,b=0;
        if(hp<1){r=c;g=x;} else if(hp<2){r=x;g=c;} else if(hp<3){g=c;b=x;} else if(hp<4){g=x;b=c;} else if(hp<5){r=x;b=c;} else {r=c;b=x;}
        const m=l-c/2; r=Math.round((r+m)*255); g=Math.round((g+m)*255); b=Math.round((b+m)*255);
        return "#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
      }
      function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;};}
      function computeSeed(){ let s=0; state.points.forEach((p,i)=>{ s^=(((p.x|0)+(p.y|0))<<(i%24)); }); return (s>>>0)||0xA5A5A5A5; }

      function buildSeedAndPalette(){
        state.seed = computeSeed(); $('seedVal').textContent = state.seed;
        const rng = mulberry32(state.seed); const base = Math.floor(rng()*360);
        const N = Number($('palSz').value); const arr=[];
        for(let i=0;i<N;i++){
          const h=(base+i*(360/N) + (rng()*2-1)*8 + 360)%360;
          const s=Math.max(0.5, Math.min(0.95, 0.62+(rng()*2-1)*0.18));
          const l=Math.max(0.35, Math.min(0.8, 0.52+(rng()*2-1)*0.15));
          arr.push(hslToHex(h,s,l));
        }
        state.palette = arr; $('palCount').textContent = arr.length+"색"; say(`[SEED] 팔레트 ${N}색 생성`);
      }

      function draw(){
        ctx.clearRect(0,0,can.width,can.height);
        ctx.fillStyle="#ffee66"; state.points.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); });
        if(state.points.length===MAXPTS){
          ctx.strokeStyle="#ffeb3b"; ctx.lineWidth=2; let idx=0;
          ctx.beginPath(); ctx.moveTo(state.points[idx].x,state.points[idx].y);
          for(let k=0;k<MAXPTS;k++){ idx=(idx+2)%MAXPTS; ctx.lineTo(state.points[idx].x,state.points[idx].y); }
          ctx.closePath(); ctx.stroke();
        }
      }
      function rel(e){ const r=can.getBoundingClientRect(); const p=(e.touches?e.touches[0]:e); return {x:p.clientX-r.left,y:p.clientY-r.top}; }
      let lock=0,last={x:-1e9,y:-1e9};
      function onCanvasClick(e){
        if(can.style.display==='none') return;
        const now=performance.now(); if(now<lock) return;
        const p=rel(e); const dx=p.x-last.x, dy=p.y-last.y; if(dx*dx+dy*dy<25) return;
        if(state.points.length>=MAXPTS) return;
        state.points.push(p); last=p; lock=now+120;
        $('ptCount').textContent=state.points.length+'/'+MAXPTS; draw();
        if(state.points.length===MAXPTS){ buildSeedAndPalette(); }
      }
      can.addEventListener('pointerdown', onCanvasClick);
      can.addEventListener('touchstart', e=>{ e.preventDefault(); onCanvasClick(e); }, {passive:false});
      window.addEventListener('resize', fit); fit();

      const speedEl=$('speed'), freqEl=$('freq'), densEl=$('dens');
      const speedVal=$('speedVal'), freqVal=$('freqVal'), densVal=$('densVal');
      const palSz=$('palSz'), palSzVal=$('palSzVal');
      const blurEl=$('blur'), blurVal=$('blurVal');
      const leftBias=$('leftBias'), leftBiasVal=$('leftBiasVal');
      const rightBias=$('rightBias'), rightBiasVal=$('rightBiasVal');

      const modeRadios = Array.from(document.querySelectorAll('input[name="mode"]'));
      const modeVal = ()=> (modeRadios.find(r=>r.checked)?.value||'bias');

      function syncUI(){
        speedVal.textContent=speedEl.value; freqVal.textContent=freqEl.value; densVal.textContent=densEl.value;
        palSzVal.textContent=palSz.value; blurVal.textContent=blurEl.value+"%";
        leftBiasVal.textContent=leftBias.value+"%"; rightBiasVal.textContent=rightBias.value+"%";
      }
      ['input','change'].forEach(ev=>{
        [speedEl,freqEl,densEl,palSz,blurEl,leftBias,rightBias].forEach(el=>el.addEventListener(ev,()=>{
          syncUI(); if(el===palSz && state.points.length===MAXPTS){ buildSeedAndPalette(); }
        }));
        modeRadios.forEach(r=>r.addEventListener(ev, syncUI));
      });
      syncUI();

      $('startBtn').onclick=()=>{
        if(state.seed==null){ alert("먼저 7점을 찍으세요."); return; }
        if(!state.running){ state.running=true; say("[RUN] 시작"); can.style.display="none"; window.dispatchEvent(new CustomEvent('app:start')); }
      };
      $('stopBtn').onclick=()=>{ state.running=false; say("[STOP] 중지"); };
      $('resetBtn').onclick=()=>{ state.running=false; state.seed=null; state.palette=[]; state.points=[];
        $('ptCount').textContent="0/7"; $('seedVal').textContent="없음"; $('palCount').textContent="0색";
        can.style.display="block"; draw(); say("[RESET] 초기화"); };

      window.AppXR = { state, say,
        ui:{ speedEl,freqEl,densEl, blurEl,leftBias,rightBias, modeVal } };
    })();
  </script>

  <!-- (B) XR 렌더/후처리: 좌/우 뷰포트별 렌더 + 개별 블러 + 3모드 -->
  <script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { HorizontalBlurShader } from 'three/addons/shaders/HorizontalBlurShader.js';
    import { VerticalBlurShader } from 'three/addons/shaders/VerticalBlurShader.js';

    const { state, say, ui } = window.AppXR;
    const { speedEl, freqEl, densEl, blurEl, leftBias, rightBias, modeVal } = ui;

    const stage=document.getElementById('stage');
    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio||1, 1.8));
    renderer.setSize(innerWidth,innerHeight);
    renderer.xr.enabled=true;
    renderer.xr.setReferenceSpaceType('local-floor');
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    stage.appendChild(renderer.domElement);

    // 장면/카메라/조명
    const scene=new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const baseCam=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,0.1,2000);
    baseCam.position.set(0,1.4,4); scene.add(baseCam);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 1.0); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(2,4,3); scene.add(dir);

    // 약간의 레퍼런스 격자/바닥(검은 화면 방지)
    const grid = new THREE.GridHelper(20, 20, 0x444444, 0x222222); grid.position.y = -1.5; scene.add(grid);

    const group=new THREE.Group(); scene.add(group);
    let cubes=[];

    function colorFromPalette(rng){
      return new THREE.Color(state.palette[Math.floor(rng()*state.palette.length)]||"#ffffff");
    }
    function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;};}

    function createBox(rng){
      // 랜덤 직육면체 + 채워진 표면 재질
      const sx = 0.25 + rng()*0.75;
      const sy = 0.25 + rng()*0.75;
      const sz = 0.25 + rng()*1.20;
      const g = new THREE.BoxGeometry(sx, sy, sz);
      const col = colorFromPalette(rng);
      const m = new THREE.MeshStandardMaterial({
        color: col, metalness: 0.05, roughness: 0.6
      });
      const mesh = new THREE.Mesh(g, m);
      mesh.position.set((rng()-0.5)*3.0, (rng()-0.5)*2.0, -10 - rng()*10);
      mesh.rotation.set(rng()*Math.PI, rng()*Math.PI, rng()*Math.PI);
      mesh.userData = { velZ: 1.5 + rng()*1.5, dieAt: performance.now() + Number(speedEl.value)*1000 };
      group.add(mesh);
      cubes.push(mesh);
    }

    function spawn(now){
      if(!state.seed || !state.palette.length || !state.running) return;
      const base=(state.seed^(now|0))>>>0;
      const rng = mulberry32(base);
      const n = Number(densEl.value);
      for(let i=0;i<n;i++) createBox(rng);
    }

    // 시작 시 즉시 한 번 스폰 (빈 화면 방지)
    window.addEventListener('app:start', ()=>{ spawn(performance.now()); });

    // per-eye composers (좌/우 각각)
    const compL = new EffectComposer(renderer);
    const passL = new RenderPass(scene, baseCam);
    const hL = new ShaderPass(HorizontalBlurShader), vL = new ShaderPass(VerticalBlurShader);
    vL.renderToScreen = true; compL.addPass(passL); compL.addPass(hL); compL.addPass(vL);

    const compR = new EffectComposer(renderer);
    const passR = new RenderPass(scene, baseCam);
    const hR = new ShaderPass(HorizontalBlurShader), vR = new ShaderPass(VerticalBlurShader);
    vR.renderToScreen = true; compR.addPass(passR); compR.addPass(hR); compR.addPass(vR);

    function setBlur(pct, w, h, isLeft){
      const amt = pct * 0.1; // 간단한 튜닝 계수
      (isLeft?hL:hR).uniforms.h.value = (amt)/(w||1);
      (isLeft?vL:vR).uniforms.v.value = (amt)/(h||1);
    }

    function renderXRPerEye(){
      const xrCam = renderer.xr.getCamera(baseCam); // ArrayCamera
      const gl = renderer.getContext();
      const totalW = gl.drawingBufferWidth, totalH = gl.drawingBufferHeight;

      compL.setSize(totalW,totalH);
      compR.setSize(totalW,totalH);

      renderer.setScissorTest(true);

      const mode = modeVal();
      const basePct = Number(blurEl.value);
      const lPct = basePct + Number(leftBias.value);
      const rPct = basePct + Number(rightBias.value);

      for(let i=0;i<2;i++){
        const sub = xrCam.cameras[i];
        const vp = sub.viewport; // {x,y,z:width,w:height}

        // 모드별 카메라 선택
        let camToUse = sub;
        if(mode==='viewL') camToUse = xrCam.cameras[0];
        else if(mode==='viewR') camToUse = xrCam.cameras[1];

        // 해당 눈의 렌더 영역 지정
        renderer.setViewport(vp.x, vp.y, vp.z, vp.w);
        renderer.setScissor(vp.x, vp.y, vp.z, vp.w);

        // 블러 강도 결정
        const pct = (mode==='bias')
          ? (i===0 ? lPct : rPct)        // 좌/우 가중치
          : (mode==='viewL' ? lPct : rPct); // 단안 보기에서도 좌/우 기준치 유지

        // 카메라/블러 동기화 후 렌더
        passL.camera = camToUse;
        passR.camera = camToUse;
        setBlur(pct, vp.z, vp.w, i===0);

        if(i===0) compL.render();
        else { renderer.clearDepth(); compR.render(); } // 깊이 버퍼 간섭 방지
      }
      renderer.setScissorTest(false);
    }

    function renderMono(){
      // 비XR(모니터)일 때: 기본 블러만 전체 화면에 적용
      const w = renderer.domElement.width, h = renderer.domElement.height;
      compL.setSize(w,h); setBlur(Number(blurEl.value), w,h, true);
      passL.camera = baseCam; compL.render();
    }

    function loop(now){
      // 스폰
      if(state.running){
        const freq = Number(freqEl.value);
        if(now % freq < 16) spawn(now); // 대략적인 주기 유지
      }
      // 업데이트
      const t=performance.now();
      for(let i=cubes.length-1;i>=0;i--){
        const m=cubes[i];
        m.rotation.x += 0.02; m.rotation.y += 0.018;
        m.position.z += m.userData.velZ * 0.016 * 60;
        if(t>=m.userData.dieAt || m.position.z > 4){
          group.remove(m); m.geometry.dispose(); m.material.dispose(); cubes.splice(i,1);
        }
      }
      // 렌더
      if(renderer.xr.isPresenting) renderXRPerEye(); else renderMono();

      // 디버그 텍스트
      document.getElementById('dbg').textContent =
        `[${renderer.xr.isPresenting?'XR':'MONO'}] cubes=${cubes.length} mode=${modeVal()} blur=${blurEl.value}% L+=${leftBias.value}% R+=${rightBias.value}%`;
    }
    renderer.setAnimationLoop(loop);

    // 리사이즈
    window.addEventListener('resize', ()=>{
      renderer.setSize(innerWidth,innerHeight,false);
      baseCam.aspect = innerWidth/innerHeight; baseCam.updateProjectionMatrix();
      compL.setSize(innerWidth,innerHeight); compR.setSize(innerWidth,innerHeight);
    });

    // VR 버튼
    const vrBtn = VRButton.createButton(renderer);
    vrBtn.style.position='fixed'; vrBtn.style.right='16px'; vrBtn.style.top='16px'; vrBtn.style.zIndex='30';
    document.body.appendChild(vrBtn);
    document.getElementById('enterVR').onclick = ()=> vrBtn.click();
  </script>
</body>
</html>
