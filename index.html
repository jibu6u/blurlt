<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Oculus/WebXR • Per-Eye Saturation + 3 Modes • v9</title>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif}
  #hud{position:fixed;left:16px;top:16px;z-index:20;background:rgba(0,0,0,.85);color:#fff;
       border:1px solid rgba(255,255,255,.15);border-radius:12px;padding:12px;min-width:380px;backdrop-filter:blur(4px)}
  #hud h3{margin:0 0 8px;color:#82d0ff;font-size:15px}
  .row{display:flex;align-items:center;gap:8px;margin:6px 0;flex-wrap:wrap}
  label{font-size:12px;white-space:nowrap}
  input[type=range]{width:190px}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.1);font-size:12px}
  button{appearance:none;border:0;border-radius:8px;padding:6px 10px;color:#fff;background:#3a86ff;cursor:pointer}
  button.ghost{background:#555}
  #dbg{position:fixed;left:16px;top:200px;color:#b3e5c1;z-index:19;font:12px/1.5 ui-monospace,Menlo,Consolas,monospace;
       background:rgba(0,0,0,.45);padding:8px 10px;border-radius:8px;min-width:380px}
  #seedCanvas{position:fixed;inset:0;display:block;z-index:10;pointer-events:auto;touch-action:none;cursor:crosshair}
  #stage{position:fixed;inset:0;z-index:0}
  #help{position:fixed;right:16px;bottom:16px;color:#ccc;background:rgba(0,0,0,.45);padding:6px 8px;border-radius:8px;font-size:12px;z-index:5}
  .mode{display:flex;gap:10px}
  .mode label{display:flex;align-items:center;gap:6px}
</style>
</head>
<body>
  <div id="hud">
    <h3>Oculus/WebXR · 좌/우 개별 채도 + 3모드 (v9)</h3>
    <div class="row">시드: <span id="seedVal" class="pill">없음</span> · 점 <span id="ptCount" class="pill">0/7</span></div>

    <div class="row"><label>팔레트 크기: <span id="palSzVal" class="pill">240</span></label>
      <input id="palSz" type="range" min="16" max="288" step="1" value="240">
      <span id="palCount" class="pill">0색</span>
    </div>

    <div class="row">
      <button id="startBtn">시작</button>
      <button id="stopBtn" class="ghost">중지</button>
      <button id="resetBtn" class="ghost">리셋</button>
      <button id="enterVR">Enter VR</button>
    </div>

    <div class="row"><label>수명(초): <span id="speedVal" class="pill">3.0</span></label>
      <input id="speed" type="range" min="1" max="10" step="0.5" value="3"></div>
    <div class="row"><label>스폰주기(ms): <span id="freqVal" class="pill">900</span></label>
      <input id="freq" type="range" min="100" max="3000" step="50" value="900"></div>
    <div class="row"><label>동시 스폰: <span id="densVal" class="pill">2</span></label>
      <input id="dens" type="range" min="1" max="6" step="1" value="2"></div>

    <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);width:100%">

    <!-- 채도 슬라이더 (기본 100%=원본, 0~250%) -->
    <div class="row"><label>채도(공통) : <span id="satVal" class="pill">100%</span></label>
      <input id="sat" type="range" min="0" max="250" step="5" value="100">
    </div>
    <div class="row"><label>좌안 추가 : <span id="leftSatVal" class="pill">0%</span></label>
      <input id="leftSat" type="range" min="-50" max="150" step="5" value="0">
    </div>
    <div class="row"><label>우안 추가 : <span id="rightSatVal" class="pill">0%</span></label>
      <input id="rightSat" type="range" min="-50" max="150" step="5" value="0">
    </div>

    <div class="row mode">
      <label><input type="radio" name="mode" value="bias" checked> 가중치 모드</label>
      <label><input type="radio" name="mode" value="viewL"> 좌안만 보기</label>
      <label><input type="radio" name="mode" value="viewR"> 우안만 보기</label>
    </div>
  </div>

  <div id="dbg">[READY] 7점을 찍어 시드를 만드세요. (클릭/터치/마우스다운 지원)</div>
  <canvas id="seedCanvas"></canvas>
  <div id="stage"></div>
  <div id="help">7점 → 시작 또는 바로 Enter VR(HTTPS). VR 입장 시 자동 스폰.</div>

  <!-- A. 시드/팔레트/입력 -->
  <script>
  (function(){
    const $=id=>document.getElementById(id);
    const can=$('seedCanvas'), ctx=can.getContext('2d'), dbg=$('dbg');
    const MAXPTS=7;
    const state={points:[], seed:null, palette:[], running:false};
    function fit(){ can.width=innerWidth; can.height=innerHeight; draw(); }
    function say(s){ dbg.textContent=s; console.log(s); }
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    function hslToHex(h,s,l){
      l=clamp(l,0,1); s=clamp(s,0,1);
      const c=(1-Math.abs(2*l-1))*s, hp=((h%360)+360)%360/60, x=c*(1-Math.abs(hp%2-1));
      let r=0,g=0,b=0;
      if(hp<1){r=c;g=x;} else if(hp<2){r=x;g=c;} else if(hp<3){g=c;b=x;} else if(hp<4){g=x;b=c;} else if(hp<5){r=x;b=c;} else {r=c;b=x;}
      const m=l-c/2; r=Math.round((r+m)*255); g=Math.round((g+m)*255); b=Math.round((b+m)*255);
      return "#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
    }
    function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;};}
    function computeSeed(){ let s=0; state.points.forEach((p,i)=>{ s^=(((p.x|0)+(p.y|0))<<(i%24)); }); return (s>>>0)||0xA5A5A5A5; }

    function buildSeedAndPalette(forceRandom=false){
      if(forceRandom && state.points.length<MAXPTS){
        // 무점 시 자동 랜덤 시드
        const rnd = Math.floor(Math.random()*0xffffffff)>>>0;
        state.seed = rnd;
      } else {
        state.seed = computeSeed();
      }
      $('seedVal').textContent = state.seed ?? '없음';
      const rng = mulberry32(state.seed||0xA5A5A5A5); const base = Math.floor(rng()*360);
      const N = Number($('palSz').value); const arr=[];
      for(let i=0;i<N;i++){
        const h=(base+i*(360/N) + (rng()*2-1)*8 + 360)%360;
        const s=clamp(0.45 + rng()*0.15, 0.45, 0.60); // 기본 적당한 채도
        const l=clamp(0.85 + rng()*0.10, 0.85, 0.95); // 매우 밝게
        arr.push(hslToHex(h,s,l));
      }
      state.palette = arr; $('palCount').textContent = arr.length+"색";
      say(`[SEED] 밝은 팔레트 ${N}색 생성 (S 0.45~0.60, L 0.85~0.95)`);
    }

    function draw(){
      ctx.clearRect(0,0,can.width,can.height);
      ctx.fillStyle="#ffee66"; state.points.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); });
      if(state.points.length===MAXPTS){
        ctx.strokeStyle="#ffeb3b"; ctx.lineWidth=2; let idx=0;
        ctx.beginPath(); ctx.moveTo(state.points[idx].x,state.points[idx].y);
        for(let k=0;k<MAXPTS;k++){ idx=(idx+2)%MAXPTS; ctx.lineTo(state.points[idx].x,state.points[idx].y); }
        ctx.closePath(); ctx.stroke();
      }
    }
    function rel(e){ const r=can.getBoundingClientRect(); const p=(e.touches?e.touches[0]:e); return {x:p.clientX-r.left,y:p.clientY-r.top}; }
    let lock=0,last={x:-1e9,y:-1e9};
    function addPoint(p){
      const dx=p.x-last.x, dy=p.y-last.y; if(dx*dx+dy*dy<25) return;
      if(state.points.length>=MAXPTS) return;
      state.points.push(p); last=p;
      $('ptCount').textContent=state.points.length+'/'+MAXPTS; draw();
      if(state.points.length===MAXPTS){ buildSeedAndPalette(); }
    }
    function onAnyDown(e){
      if(can.style.display==='none') return;
      const now=performance.now(); if(now<lock) return; lock=now+80;
      addPoint(rel(e)); e.preventDefault?.();
    }
    can.addEventListener('pointerdown', onAnyDown);
    can.addEventListener('mousedown', onAnyDown);
    can.addEventListener('click', onAnyDown);
    can.addEventListener('touchstart', onAnyDown, {passive:false});
    window.addEventListener('resize', fit); fit();

    const speedEl=$('speed'), freqEl=$('freq'), densEl=$('dens');
    const speedVal=$('speedVal'), freqVal=$('freqVal'), densVal=$('densVal');
    const palSz=$('palSz'), palSzVal=$('palSzVal');

    const satEl=$('sat'), leftSat=$('leftSat'), rightSat=$('rightSat');
    const satVal=$('satVal'), leftSatVal=$('leftSatVal'), rightSatVal=$('rightSatVal');

    const modeRadios = Array.from(document.querySelectorAll('input[name="mode"]'));
    const modeVal = ()=> (modeRadios.find(r=>r.checked)?.value||'bias');

    function syncUI(){
      speedVal.textContent=speedEl.value; freqVal.textContent=freqEl.value; densVal.textContent=densEl.value;
      palSzVal.textContent=palSz.value;
      satVal.textContent=satEl.value+"%"; leftSatVal.textContent=leftSat.value+"%"; rightSatVal.textContent=rightSat.value+"%";
      window.dispatchEvent(new CustomEvent('ui:sat-change')); // 실시간 반영
    }
    ['input','change'].forEach(ev=>{
      [speedEl,freqEl,densEl,palSz,satEl,leftSat,rightSat].forEach(el=>el.addEventListener(ev,()=>{
        if(el===palSz){ if(state.points.length===MAXPTS || state.seed!=null) buildSeedAndPalette(true); }
        syncUI();
      }));
      modeRadios.forEach(r=>r.addEventListener(ev, syncUI));
    });
    syncUI();

    $('startBtn').onclick=()=>{
      if(state.seed==null){ buildSeedAndPalette(true); }
      if(!state.running){ state.running=true; say("[RUN] 시작"); can.style.display="none"; window.dispatchEvent(new CustomEvent('app:start')); }
    };
    $('stopBtn').onclick=()=>{ state.running=false; say("[STOP] 중지"); };
    $('resetBtn').onclick=()=>{ state.running=false; state.seed=null; state.palette=[]; state.points=[];
      $('ptCount').textContent="0/7"; $('seedVal').textContent="없음"; $('palCount').textContent="0색";
      can.style.display="block"; draw(); say("[RESET] 초기화"); };

    window.AppXR = { state, say,
      ui:{ speedEl,freqEl,densEl, satEl,leftSat,rightSat, modeVal },
      util:{ buildSeedAndPalette }
    };
  })();
  </script>

  <!-- B. XR 렌더/후처리(채도 전용 Shader) -->
  <script type="module">
  import * as THREE from 'three';
  import { VRButton } from 'three/addons/webxr/VRButton.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

  // 간단 채도 셰이더
  const SaturationShader = {
    uniforms: { tDiffuse: { value: null }, saturation: { value: 1.0 } },
    vertexShader: /* glsl */`
      varying vec2 vUv;
      void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
    `,
    fragmentShader: /* glsl */`
      uniform sampler2D tDiffuse;
      uniform float saturation;
      varying vec2 vUv;
      vec3 sat(vec3 c, float s){
        float luma = dot(c, vec3(0.299, 0.587, 0.114));
        return mix(vec3(luma), c, s);
      }
      void main(){
        vec4 col = texture2D(tDiffuse, vUv);
        col.rgb = sat(col.rgb, saturation);
        gl_FragColor = col;
      }
    `
  };

  const { state, say, ui, util } = window.AppXR;
  const { speedEl, freqEl, densEl, satEl, leftSat, rightSat, modeVal } = ui;

  const stage=document.getElementById('stage');
  const renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio||1, 1.8));
  renderer.setSize(innerWidth,innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.25; // 조금 더 밝게
  renderer.xr.enabled=true;
  renderer.xr.setReferenceSpaceType('local-floor');
  stage.appendChild(renderer.domElement);

  const scene=new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const baseCam=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,0.1,2000);
  baseCam.position.set(0,1.4,4); scene.add(baseCam);

  // 더 밝은 조명
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.9); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.2); dir.position.set(2,4,3); scene.add(dir);

  const group=new THREE.Group(); scene.add(group);
  let cubes=[];

  function colorFromPalette(rng){ return new THREE.Color(state.palette[Math.floor(rng()*state.palette.length)]||"#ffffff"); }
  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return ((t^(t>>>14))>>>0)/4294967296;};}

  // 정면 접근(멀리서 → 사용자)
  function createBox(rng){
    const sx = 0.25 + rng()*0.75;
    const sy = 0.25 + rng()*0.75;
    const sz = 0.25 + rng()*1.20;
    const g = new THREE.BoxGeometry(sx, sy, sz);
    const col = colorFromPalette(rng);
    const m = new THREE.MeshStandardMaterial({
      color: col, metalness: 0.05, roughness: 0.45,
      transparent: true, opacity: 1.0,
      emissive: col.clone().multiplyScalar(0.25), emissiveIntensity: 0.6
    });
    const mesh = new THREE.Mesh(g, m);

    const zStart = -14 - rng()*6;         // 더 멀리서 시작
    const xStart = (rng()-0.5)*3.2;
    const yStart = (rng()-0.5)*2.0;
    mesh.position.set(xStart, yStart, zStart);
    mesh.rotation.set(rng()*Math.PI, rng()*Math.PI, rng()*Math.PI);

    const lifeMs = Number(speedEl.value)*1000;
    const lifeS  = Math.max(lifeMs/1000, 0.5);
    const zEnd   =  2.8;
    const velZ   = (zEnd - zStart) / lifeS;
    const velX   = (rng()*0.16 - 0.08);
    const swayA  = 0.06 + rng()*0.10;     // Y 흔들림 낮춤(춤추는 느낌 최소화)
    const swayHz = 0.5 + rng()*0.6;

    mesh.userData = {
      zEnd, velZ, velX,
      yBase: yStart, swayA, swayHz, phase: rng()*Math.PI*2,
      dieAt: performance.now() + lifeMs, lifeTotal: lifeMs
    };

    group.add(mesh); cubes.push(mesh);
  }

  function spawn(now){
    if(!state.palette.length){ return; }
    if(!state.running) return;
    const base=(state.seed^(now|0))>>>0;
    const rng = mulberry32(base);
    for(let i=0;i<Number(densEl.value);i++) createBox(rng);
  }
  window.addEventListener('app:start', ()=>{ spawn(performance.now()); });

  // ===== Per-eye composers (채도 전용) =====
  const compL = new EffectComposer(renderer);
  const passL = new RenderPass(scene, baseCam);
  const satPassL = new ShaderPass(SaturationShader); satPassL.renderToScreen = true;
  compL.addPass(passL); compL.addPass(satPassL);

  const compR = new EffectComposer(renderer);
  const passR = new RenderPass(scene, baseCam);
  const satPassR = new ShaderPass(SaturationShader); satPassR.renderToScreen = true;
  compR.addPass(passR); compR.addPass(satPassR);

  function setSaturation(pct, isLeft){
    // pct: 0~250 → 0.0~2.5 배
    const f = Math.max(0, pct) / 100;
    (isLeft ? satPassL : satPassR).uniforms.saturation.value = f;
  }

  function renderXRPerEye(){
    const xrCam = renderer.xr.getCamera(baseCam);
    const gl = renderer.getContext();
    const totalW = gl.drawingBufferWidth, totalH = gl.drawingBufferHeight;
    compL.setSize(totalW,totalH); compR.setSize(totalW,totalH);
    renderer.setScissorTest(true);

    const mode = modeVal();
    const basePct = Number(satEl.value);
    const lPct = basePct + Number(leftSat.value);
    const rPct = basePct + Number(rightSat.value);

    for(let i=0;i<2;i++){
      const sub = xrCam.cameras[i];
      const vp = sub.viewport;
      let camToUse = sub;
      if(mode==='viewL') camToUse = xrCam.cameras[0];
      else if(mode==='viewR') camToUse = xrCam.cameras[1];

      renderer.setViewport(vp.x, vp.y, vp.z, vp.w);
      renderer.setScissor(vp.x, vp.y, vp.z, vp.w);

      const pct = (mode==='bias') ? (i===0?lPct:rPct) : (mode==='viewL'?lPct:rPct);
      passL.camera = camToUse; passR.camera = camToUse;
      setSaturation(pct, i===0);

      if(i===0) compL.render(); else { renderer.clearDepth(); compR.render(); }
    }
    renderer.setScissorTest(false);
  }

  function renderMono(){
    const w = renderer.domElement.width, h = renderer.domElement.height;
    compL.setSize(w,h);
    setSaturation(Number(satEl.value), true);
    passL.camera = baseCam; compL.render();
  }

  // UI에서 채도 변경 시 즉시 반영
  window.addEventListener('ui:sat-change', ()=>{
    setSaturation(Number(satEl.value) + Number(leftSat.value), true);
    setSaturation(Number(satEl.value) + Number(rightSat.value), false);
  });

  // VR 세션 진입 시 자동 스폰 & 자동 실행
  renderer.xr.addEventListener('sessionstart', ()=>{
    if(state.seed==null || !state.palette.length){ util.buildSeedAndPalette(true); }
    // 시드 캔버스 숨김 + 실행
    const sc = document.getElementById('seedCanvas'); if(sc) sc.style.display='none';
    state.running = true;
    setTimeout(()=>spawn(performance.now()), 50);
  });

  // 메인 루프
  let prevTime = performance.now(), lastSpawn = 0;
  function loop(now){
    const dt = Math.min((now - prevTime)/1000, 0.05); prevTime = now;

    if(state.running){
      const freq = Number(freqEl.value);
      if(now - lastSpawn >= freq){ spawn(now); lastSpawn = now; }
    }

    const t = performance.now();
    for(let i=cubes.length-1;i>=0;i--){
      const m = cubes[i], u = m.userData;

      m.rotation.x += 0.6 * dt;
      m.rotation.y += 0.5 * dt;

      u.phase += dt * 2*Math.PI * u.swayHz;
      m.position.z += u.velZ * dt;
      m.position.x += u.velX * dt;
      m.position.y = u.yBase + Math.sin(u.phase) * u.swayA;

      let alpha = THREE.MathUtils.clamp((u.dieAt - t) / u.lifeTotal, 0, 1);
      if(m.position.z >= u.zEnd){
        alpha *= (1 - THREE.MathUtils.clamp((m.position.z - u.zEnd)/0.8, 0, 1));
      }
      m.material.opacity = alpha;

      if(alpha<=0.01 || t>=u.dieAt || m.position.z>u.zEnd+1.0){
        group.remove(m); m.geometry.dispose(); m.material.dispose(); cubes.splice(i,1);
      }
    }

    if(renderer.xr.isPresenting) renderXRPerEye(); else renderMono();

    document.getElementById('dbg').textContent =
      `[${renderer.xr.isPresenting?'XR':'MONO'}] cubes=${cubes.length} mode=${modeVal()} sat=${satEl.value}% L+=${leftSat.value}% R+=${rightSat.value}%`;
  }
  renderer.setAnimationLoop(loop);

  window.addEventListener('resize', ()=>{
    renderer.setSize(innerWidth,innerHeight,false);
    baseCam.aspect = innerWidth/innerHeight; baseCam.updateProjectionMatrix();
    compL.setSize(innerWidth,innerHeight); compR.setSize(innerWidth,innerHeight);
  });

  const vrBtn = VRButton.createButton(renderer);
  vrBtn.style.position='fixed'; vrBtn.style.right='16px'; vrBtn.style.top='16px'; vrBtn.style.zIndex='30';
  document.body.appendChild(vrBtn);
  document.getElementById('enterVR').onclick = ()=> vrBtn.click();
  </script>
</body>
</html>
